import enum
import uuid
from datetime import datetime
from typing import Any, Dict, List, Optional

from sqlalchemy import (
    Boolean,
    Column,
    Computed,
    DateTime,
    Enum,
    Float,
    ForeignKey,
    Index,
    Integer,
    String,
    Table,
    Text,
    UniqueConstraint,
    func,
)
from sqlalchemy.dialects.postgresql import ARRAY, JSONB, TSVECTOR, UUID
from sqlalchemy.orm import (
    DeclarativeBase,
    Mapped,
    declared_attr,
    mapped_column,
    relationship,
)
from pgvector.sqlalchemy import Vector
from websockets import serve

VECTOR_DIM = 768


class EventStatus(str, enum.Enum):
    DRAFT = "draft"  # Just created, maybe incomplete
    ENHANCED = "enhanced"  # LLM has written the summary
    PUBLISHED = "published"  # Live on Frontend
    ARCHIVED = "archived"  # Old news, removed from feed
    MERGED = "merged"  # Dissolved into another event (Tombstone)


class JobStatus(enum.Enum):
    PENDING = "PENDING"
    PROCESSING = "PROCESSING"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"
    WAITING = "WAITING"
    APPROVED = "APPROVED"
    REJECTED = "REJECTED"

class ArticlesQueueName(enum.Enum):
    FILTER = "filter"
    ENRICHER = "enricher"
    CLUSTER = "cluster"
    ANALYZER = "analyzer"


class EventsQueueName(enum.Enum):
    ENHANCER = "enhancer"
    PUBLISHER = "publisher"


class BaseModel(DeclarativeBase):
    """Modern SQLAlchemy 2.0 Base."""

    @declared_attr.directive
    def __tablename__(cls) -> str:
        return cls.__name__.lower()


class NewsEventModel(BaseModel):
    @declared_attr.directive
    def __tablename__(cls) -> str:
        return "news_events"

    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), primary_key=True, default=uuid.uuid4
    )
    # this title will be generated by llm or human
    title: Mapped[str] = mapped_column(String, index=True)

    # Subtitles/Summaries generated later by LLM
    subtitle: Mapped[Optional[str]] = mapped_column(String, nullable=True, index=True)
    summary: Mapped[Optional[Dict[str, str]]] = mapped_column(
        JSONB,
        default=dict,
        nullable=True,
        comment='Structure: {"left": "markdown", "right": "markdown", "center": "markdown"}',
    )

    # this is the count of interests
    interest_counts: Mapped[Optional[Dict[str, Dict[str, int]]]] = mapped_column(
        JSONB, default=dict, nullable=True
    )
    # This is the count of main topics
    main_topic_counts: Mapped[Optional[Dict[str, int]]] = mapped_column(
        JSONB, default=dict, nullable=True
    )

    ownership_stats: Mapped[Optional[Dict[str, int]]] = mapped_column(
        JSONB, default=dict, nullable=True
    )

    article_count: Mapped[int] = mapped_column(Integer, default=1, index=True)
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now()
    )
    last_updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        onupdate=func.now(),
        index=True,
    )

    is_active: Mapped[bool] = mapped_column(Boolean, default=True, index=True)
    status: Mapped[EventStatus] = mapped_column(
        Enum(EventStatus), default=EventStatus.DRAFT, index=True
    )

    fe_priority: Mapped[int] = mapped_column(Integer, default=10)
    bias_distribution: Mapped[Dict[str, List[str]]] = mapped_column(JSONB, default=dict)
    stance_distribution: Mapped[Dict[str, Dict[str, int]]] = mapped_column(
        JSONB, default=dict
    )
    stance: Mapped[Optional[float]] = mapped_column(Float, nullable=True, default=0.0)
    clickbait_distribution: Mapped[Dict[str, float]] = mapped_column(
        JSONB, default=dict
    )
    article_counts_by_bias: Mapped[Dict[str, int]] = mapped_column(JSONB, default=dict)

    last_summarized_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), default=func.now()
    )
    articles_at_last_summary: Mapped[int] = mapped_column(Integer, default=0)

    # Centroid is required to create an event, so keep NOT NULL
    embedding_centroid: Mapped[List[float]] = mapped_column(Vector(VECTOR_DIM))

    # --- HYBRID SEARCH FIELDS ---
    search_text: Mapped[Optional[str]] = mapped_column(Text, nullable=True)

    # Computed automatically by Postgres
    search_vector_ts: Mapped[str] = mapped_column(
        TSVECTOR, Computed("to_tsvector('portuguese', search_text)", persisted=True)
    )

    articles: Mapped[List["ArticleModel"]] = relationship(back_populates="event")

    # Merged Event Logic (Tombstoning)
    merged_into_id: Mapped[Optional[uuid.UUID]] = mapped_column(
        ForeignKey("news_events.id"), nullable=True
    )

    # Self-referential relationship
    merged_into: Mapped[Optional["NewsEventModel"]] = relationship(
        remote_side=[id], backref="merged_children"
    )
    hot_score: Mapped[float] = mapped_column(
        Float, default=0.0, server_default="0.0", index=True
    )
    published_at: Mapped[Optional[datetime]] = mapped_column(
        DateTime(timezone=True), nullable=True, index=True
    )
    is_blind_spot: Mapped[Optional[bool]] = mapped_column(
        Boolean, nullable=True, index=True
    )
    blind_spot_side: Mapped[Optional[str]] = mapped_column(
        String, nullable=True, index=True
    )

    # (e.g., if CNN had it at #1, this is 1)
    best_source_rank: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)

    first_article_date = mapped_column(DateTime(timezone=True), nullable=True)
    last_article_date = mapped_column(DateTime(timezone=True), nullable=True)
    # New Field: Semantic importance derived by LLM (0-100)
    ai_impact_score: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)
    ai_impact_reasoning: Mapped[Optional[str]] = mapped_column(String, nullable=True)
    # Optional: Categorical classification for weighting!
    # e.g., "POLITICS", "ENTERTAINMENT", "SCIENCE", "CRIME"
    category_tag: Mapped[Optional[str]] = mapped_column(String, nullable=True)
    is_international: Mapped[bool] = mapped_column(Boolean, default=False, index=True)
    publisher_insights: Mapped[Optional[list[str]]] = mapped_column(
        ARRAY(Text), nullable=True
    )
    sources_snapshot: Mapped[dict[str, Dict[str, str]]] = mapped_column(
        JSONB, default=dict
    )

    # New Field: Sum of editorial weights (e.g. CNN#1 + Fox#5)
    editorial_score: Mapped[float] = mapped_column(Float, default=0.0)
    __table_args__ = (
        Index(
            "ix_active_events_embedding",
            "embedding_centroid",
            postgresql_using="hnsw",
            postgresql_with={"m": 16, "ef_construction": 64},
            postgresql_ops={"embedding_centroid": "vector_cosine_ops"},
            postgresql_where=(is_active == True),
        ),
        Index("ix_events_search_vector", "search_vector_ts", postgresql_using="gin"),
    )


article_author_association = Table(
    "article_authors",
    BaseModel.metadata,
    Column("article_id", ForeignKey("articles.id"), primary_key=True),
    Column("author_id", ForeignKey("authors.id"), primary_key=True),
)


class ArticleModel(BaseModel):
    @declared_attr.directive
    def __tablename__(cls) -> str:
        return "articles"

    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), primary_key=True, default=uuid.uuid4
    )

    url_hash: Mapped[str] = mapped_column(String(64), unique=True, index=True)
    original_url: Mapped[str] = mapped_column(String)
    title: Mapped[str] = mapped_column(String)
    published_date: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), nullable=True
    )
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now()
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now(), onupdate=func.now()
    )
    summary_date: Mapped[datetime] = mapped_column(DateTime(timezone=True))
    summary_status: Mapped[JobStatus] = mapped_column(
        Enum(JobStatus), default=JobStatus.PENDING, index=True
    )

    subtitle: Mapped[Optional[str]] = mapped_column(String, nullable=True)
    summary: Mapped[Optional[str]] = mapped_column(String, nullable=True)

    stance: Mapped[Optional[float]] = mapped_column(Float, nullable=True)
    stance_reasoning: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    clickbait_score: Mapped[Optional[float]] = mapped_column(Float, nullable=True)
    clickbait_reasoning: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    # Main topics in this article "politics" "economy" "etc.."
    main_topics: Mapped[Optional[List[str]]] = mapped_column(ARRAY(Text), nullable=True)
    # entities are a flat list of entities
    entities: Mapped[Optional[List[str]]] = mapped_column(ARRAY(Text), nullable=True)
    # interests are a categorized dict of entities
    interests: Mapped[Optional[Dict[str, List[str]]]] = mapped_column(
        JSONB, default=dict, nullable=True
    )
    # key points this article is talking about
    key_points: Mapped[Optional[List[str]]] = mapped_column(ARRAY(Text), nullable=True)

    embedding: Mapped[Optional[List[float]]] = mapped_column(
        Vector(VECTOR_DIM), nullable=True
    )

    newspaper_id: Mapped[uuid.UUID] = mapped_column(ForeignKey("newspapers.id"))
    newspaper: Mapped["NewspaperModel"] = relationship(back_populates="articles")

    event_id: Mapped[Optional[uuid.UUID]] = mapped_column(
        ForeignKey("news_events.id"), nullable=True
    )
    event: Mapped["NewsEventModel"] = relationship(back_populates="articles")

    authors: Mapped[List["AuthorModel"]] = relationship(
        secondary=article_author_association, back_populates="articles"
    )

    content: Mapped[Optional[str]] = mapped_column(Text, deferred=True, nullable=True)

    source_rank: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)
    __table_args__ = (Index("ix_article_event_date", "event_id", "published_date"),)


class NewspaperModel(BaseModel):
    @declared_attr.directive
    def __tablename__(cls) -> str:
        return "newspapers"

    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), primary_key=True, default=uuid.uuid4
    )
    home_url: Mapped[str] = mapped_column(String, nullable=True)
    name: Mapped[str] = mapped_column(String)
    bias: Mapped[str] = mapped_column(String)
    description: Mapped[str] = mapped_column(Text)
    icon_url: Mapped[str] = mapped_column(String)
    logo_url: Mapped[str] = mapped_column(String)
    ownership_type = mapped_column(String, nullable=True)
    feeds: Mapped[List["FeedModel"]] = relationship(
        back_populates="newspaper", cascade="all, delete-orphan"
    )
    articles: Mapped[List["ArticleModel"]] = relationship(back_populates="newspaper")
    authors: Mapped[List["AuthorModel"]] = relationship(
        back_populates="newspaper", cascade="all, delete-orphan"
    )


class FeedModel(BaseModel):
    @declared_attr.directive
    def __tablename__(cls) -> str:
        return "feeds"

    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), primary_key=True, default=uuid.uuid4
    )
    newspaper_id: Mapped[uuid.UUID] = mapped_column(ForeignKey("newspapers.id"))
    url: Mapped[str] = mapped_column(String, unique=True, index=True)
    newspaper: Mapped["NewspaperModel"] = relationship(back_populates="feeds")
    is_active: Mapped[bool] = mapped_column(Boolean, default=True, index=True)
    blocklist: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    allowed_sections: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    url_pattern: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    feed_type: Mapped[str] = mapped_column(String, server_default="sitemap")
    is_ranked: Mapped[bool] = mapped_column(Boolean, default=False)
    # New flag: If True, uses Playwright. If False, uses aiohttp.
    use_browser_render: Mapped[bool] = mapped_column(
        Boolean, default=False, server_default="false"
    )

    # Optional: How many times to scroll down to load more content?
    scroll_depth: Mapped[int] = mapped_column(Integer, default=1, server_default="1")


class AuthorModel(BaseModel):
    @declared_attr.directive
    def __tablename__(cls) -> str:
        return "authors"

    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), primary_key=True, default=uuid.uuid4
    )
    name: Mapped[str] = mapped_column(String)
    newspaper_id: Mapped[uuid.UUID] = mapped_column(ForeignKey("newspapers.id"))
    newspaper: Mapped["NewspaperModel"] = relationship(back_populates="authors")
    articles: Mapped[List["ArticleModel"]] = relationship(
        secondary=article_author_association, back_populates="authors"
    )


class MergeProposalModel(BaseModel):
    @declared_attr.directive
    def __tablename__(cls) -> str:
        return "merge_proposals"

    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), primary_key=True, default=uuid.uuid4
    )

    # Type of merge: 'article_merge' (Article -> Event) or 'event_merge' (Event -> Event)
    proposal_type: Mapped[str] = mapped_column(String, default="article_merge")

    # The Source (One of these must be set)
    source_article_id: Mapped[Optional[uuid.UUID]] = mapped_column(
        ForeignKey("articles.id"), nullable=True
    )
    source_event_id: Mapped[Optional[uuid.UUID]] = mapped_column(
        ForeignKey("news_events.id"), nullable=True
    )

    # The Target (Always an Event)
    target_event_id: Mapped[uuid.UUID] = mapped_column(ForeignKey("news_events.id"))

    distance_score: Mapped[float] = mapped_column(Float)
    reasoning: Mapped[Optional[str]] = mapped_column(Text, nullable=True)

    # Status: PENDING, APPROVED, REJECTED, FAILED, PROCESSING
    status: Mapped[JobStatus] = mapped_column(
        Enum(JobStatus), default=JobStatus.PENDING
    )

    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), default=func.now()
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), default=func.now(), onupdate=func.now()
    )
    # Relationships
    source_article: Mapped[Optional["ArticleModel"]] = relationship(
        foreign_keys=[source_article_id]
    )
    source_event: Mapped[Optional["NewsEventModel"]] = relationship(
        foreign_keys=[source_event_id]
    )
    target_event: Mapped["NewsEventModel"] = relationship(
        foreign_keys=[target_event_id]
    )

    __table_args__ = (
        # Unique constraint for Article merges
        UniqueConstraint(
            "source_article_id", "target_event_id", name="uq_article_merge_pair"
        ),
        # Unique constraint for Event merges
        UniqueConstraint(
            "source_event_id", "target_event_id", name="uq_event_merge_pair"
        ),
    )




class ArticlesQueueModel(BaseModel):
    @declared_attr.directive
    def __tablename__(cls) -> str:
        return "articles_queue"

    id = Column(Integer, primary_key=True, index=True)
    article_id: Mapped[uuid.UUID] = mapped_column(ForeignKey("articles.id"))
    article: Mapped["ArticleModel"] = relationship()

    # # Intelligence
    # estimated_tokens = Column(Integer) # Calculated during filter stage

    # Worker Control
    status: Mapped[JobStatus] = mapped_column(
        Enum(JobStatus), default=JobStatus.PENDING, index=True
    )
    attempts: Mapped[int] = mapped_column(Integer, default=0)
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), default=func.now()
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), default=func.now(), onupdate=func.now()
    )
    msg: Mapped[str] = mapped_column(Text, nullable=True)
    queue_name: Mapped[ArticlesQueueName] = mapped_column(
        Enum(ArticlesQueueName), default=ArticlesQueueName.FILTER, index=True
    )

    __table_args__ = (
        Index(
            "ix_queue_pending_fifo",
            "updated_at",
            "queue_name",
            postgresql_where=(status == JobStatus.PENDING),
        ),

    )


class EventsQueueModel(BaseModel):
    @declared_attr.directive
    def __tablename__(cls) -> str:
        return "events_queue"

    id = Column(Integer, primary_key=True, index=True)
    event_id: Mapped[uuid.UUID] = mapped_column(ForeignKey("news_events.id"))
    event: Mapped["NewsEventModel"] = relationship()

    status: Mapped[JobStatus] = mapped_column(
        Enum(JobStatus), default=JobStatus.PENDING, index=True
    )
    attempts: Mapped[int] = mapped_column(Integer, default=0)
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), default=func.now()
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), default=func.now(), onupdate=func.now()
    )
    msg: Mapped[str] = mapped_column(Text, nullable=True)
    queue_name: Mapped[EventsQueueName] = mapped_column(
        Enum(EventsQueueName), default=EventsQueueName.ENHANCER, index=True
    )

    __table_args__ = (
        Index(
            "ix_events_queue_pending_fifo",
            "updated_at",
            "queue_name",
            postgresql_where=(status == JobStatus.PENDING),
        ),

    )


class AuditLogModel(BaseModel):
    @declared_attr.directive
    def __tablename__(cls) -> str:
        return "audit_logs"

    id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    target_table: Mapped[str] = mapped_column(String, index=True)
    target_id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), index=True)
    action: Mapped[str] = mapped_column(String)  # INSERT, UPDATE, DELETE

    # What changed? (e.g., {"status": [OLD, NEW]})
    changes: Mapped[Dict[str, Any]] = mapped_column(JSONB, default=dict)

    # Who did it? (Optional, if you have user context)
    actor_id: Mapped[Optional[str]] = mapped_column(String, nullable=True)

    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())


class RateLimitMetric(str, enum.Enum):
    TOKENS = "tokens"
    REQUESTS = "requests"


class RateLimitConfigModel(BaseModel):
    @declared_attr.directive
    def __tablename__(cls) -> str:
        return "rate_limit_config"

    model_id: Mapped[str] = mapped_column(String, primary_key=True)
    metric: Mapped[RateLimitMetric] = mapped_column(Enum(RateLimitMetric), primary_key=True)

    # Example: 86400 for 1 day, 60 for 1 minute
    window_seconds: Mapped[int] = mapped_column(Integer)

    # Example: 1000000 tokens
    limit_value: Mapped[int] = mapped_column(Integer)


class RateLimitUsageModel(BaseModel):
    @declared_attr.directive
    def __tablename__(cls) -> str:
        return "rate_limit_usage"

    # Key format: "{model_id}:{metric}"
    key: Mapped[str] = mapped_column(String, primary_key=True)

    current_value: Mapped[int] = mapped_column(Integer, default=0)
    window_start: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())
