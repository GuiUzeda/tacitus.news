import enum
import uuid
from datetime import datetime
from typing import Dict, List, Optional

from sqlalchemy import (
    Boolean,
    Column,
    Computed,
    DateTime,
    Enum,
    Float,
    ForeignKey,
    Index,
    Integer,
    String,
    Table,
    Text,
    UniqueConstraint,
    func,
)
from sqlalchemy.dialects.postgresql import ARRAY, JSONB, TSVECTOR, UUID
from sqlalchemy.orm import (
    DeclarativeBase,
    Mapped,
    declared_attr,
    mapped_column,
    relationship,
)
from pgvector.sqlalchemy import Vector

VECTOR_DIM = 768


class EventStatus(str, enum.Enum):
    DRAFT = "draft"  # Just created, maybe incomplete
    ENHANCED = "enhanced"  # LLM has written the summary
    PUBLISHED = "published"  # Live on Frontend
    ARCHIVED = "archived"  # Old news, removed from feed
    MERGED = "merged"  # Dissolved into another event (Tombstone)


class JobStatus(enum.Enum):
    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"


class BaseModel(DeclarativeBase):
    """Modern SQLAlchemy 2.0 Base."""

    @declared_attr.directive
    def __tablename__(cls) -> str:
        return cls.__name__.lower()


class NewsEventModel(BaseModel):
    @declared_attr.directive
    def __tablename__(cls) -> str:
        return "news_events"

    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), primary_key=True, default=uuid.uuid4
    )
    # this title will be generated by llm or human
    title: Mapped[str] = mapped_column(String, index=True)

    # Subtitles/Summaries generated later by LLM
    subtitle: Mapped[Optional[str]] = mapped_column(String, nullable=True, index=True)
    summary: Mapped[Optional[Dict[str, str]]] = mapped_column(
        JSONB,
        default=dict,
        nullable=True,
        comment='Structure: {"left": "markdown", "right": "markdown", "center": "markdown"}',
    )
    
    # interests are entities with classification
    interest_counts: Mapped[Optional[Dict[str, Dict[str, int]]]] = mapped_column(
        JSONB, default=dict, nullable=True
    )
    
    ownership_stats: Mapped[Optional[Dict[str, int]]] = mapped_column(
        JSONB, default=dict, nullable=True
    )
    
    article_count: Mapped[int] = mapped_column(Integer, default=1)
    created_at: Mapped[datetime] = mapped_column(DateTime, server_default=func.now())
    last_updated_at: Mapped[datetime] = mapped_column(
        DateTime, server_default=func.now(), onupdate=func.now()
    )

    is_active: Mapped[bool] = mapped_column(Boolean, default=True, index=True)
    status: Mapped[EventStatus] = mapped_column(
        Enum(EventStatus), default=EventStatus.DRAFT, index=True
    )

    fe_priority: Mapped[int] = mapped_column(Integer, default=10)
    bias_distribution: Mapped[Dict[str, List[str]]] = mapped_column(JSONB, default=dict)
    stance_distribution: Mapped[Dict[str, Dict[str, int]]] = mapped_column(
        JSONB, default=dict
    )
    clickbait_distribution: Mapped[Dict[str, float]] = mapped_column(JSONB, default=dict)
    article_counts_by_bias: Mapped[Dict[str, int]] = mapped_column(JSONB, default=dict)

    last_summarized_at: Mapped[datetime] = mapped_column(DateTime, default=func.now())
    articles_at_last_summary: Mapped[int] = mapped_column(Integer, default=0)

    # Centroid is required to create an event, so keep NOT NULL
    embedding_centroid: Mapped[List[float]] = mapped_column(Vector(VECTOR_DIM))

    # --- HYBRID SEARCH FIELDS ---
    search_text: Mapped[Optional[str]] = mapped_column(Text, nullable=True)

    # Computed automatically by Postgres
    search_vector_ts: Mapped[str] = mapped_column(
        TSVECTOR, Computed("to_tsvector('portuguese', search_text)", persisted=True)
    )

    articles: Mapped[List["ArticleModel"]] = relationship(back_populates="event")
    
    # Merged Event Logic (Tombstoning)
    merged_into_id: Mapped[Optional[uuid.UUID]] = mapped_column(
        ForeignKey("news_events.id"), nullable=True
    )
    
    # Self-referential relationship
    merged_into: Mapped[Optional["NewsEventModel"]] = relationship(
        remote_side=[id], backref="merged_children"
    )

    __table_args__ = (
        Index(
            "ix_active_events_embedding",
            "embedding_centroid",
            postgresql_using="hnsw",
            postgresql_with={"m": 16, "ef_construction": 64},
            postgresql_ops={"embedding_centroid": "vector_cosine_ops"},
            postgresql_where=(is_active == True),
        ),
        Index("ix_events_search_vector", "search_vector_ts", postgresql_using="gin"),
    )


article_author_association = Table(
    "article_authors",
    BaseModel.metadata,
    Column("article_id", ForeignKey("articles.id"), primary_key=True),
    Column("author_id", ForeignKey("authors.id"), primary_key=True),
)


class ArticleModel(BaseModel):
    @declared_attr.directive
    def __tablename__(cls) -> str:
        return "articles"

    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), primary_key=True, default=uuid.uuid4
    )

    url_hash: Mapped[str] = mapped_column(String(64), unique=True, index=True)
    original_url: Mapped[str] = mapped_column(String)
    title: Mapped[str] = mapped_column(String)
    published_date: Mapped[datetime] = mapped_column(DateTime)
    summary_date: Mapped[datetime] = mapped_column(DateTime)
    summary_status: Mapped[JobStatus] = mapped_column(
        Enum(JobStatus), default=JobStatus.PENDING, index=True
    )

    subtitle: Mapped[Optional[str]] = mapped_column(String, nullable=True)
    summary: Mapped[Optional[str]] = mapped_column(String, nullable=True)

    stance: Mapped[Optional[float]] = mapped_column(Float, nullable=True)
    stance_reasoning: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    clickbait_score: Mapped[Optional[float]] = mapped_column(Float, nullable=True)
    clickbait_reasoning: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    main_topics: Mapped[Optional[List[str]]] = mapped_column(ARRAY(Text), nullable=True)
    entities: Mapped[Optional[List[str]]] = mapped_column(ARRAY(Text), nullable=True)
    
    interests: Mapped[Optional[Dict[str, List[str]]]] = mapped_column(
        JSONB, default=dict, nullable=True
    )

    key_points: Mapped[Optional[List[str]]] = mapped_column(ARRAY(Text), nullable=True)

    embedding: Mapped[Optional[List[float]]] = mapped_column(
        Vector(VECTOR_DIM), nullable=True
    )

    newspaper_id: Mapped[uuid.UUID] = mapped_column(ForeignKey("newspapers.id"))
    newspaper: Mapped["NewspaperModel"] = relationship(back_populates="articles")

    event_id: Mapped[Optional[uuid.UUID]] = mapped_column(
        ForeignKey("news_events.id"), nullable=True
    )
    event: Mapped["NewsEventModel"] = relationship(back_populates="articles")

    authors: Mapped[List["AuthorModel"]] = relationship(
        secondary=article_author_association, back_populates="articles"
    )
    contents: Mapped[List["ArticleContentModel"]] = relationship(
        back_populates="article", cascade="all, delete-orphan"
    )

    __table_args__ = (Index("ix_article_event_date", "event_id", "published_date"),)


class ArticleContentModel(BaseModel):
    @declared_attr.directive
    def __tablename__(cls) -> str:
        return "article_contents"

    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), primary_key=True, default=uuid.uuid4
    )
    article_id: Mapped[uuid.UUID] = mapped_column(ForeignKey("articles.id"), index=True)
    content: Mapped[str] = mapped_column(Text)
    created_at: Mapped[datetime] = mapped_column(DateTime, server_default=func.now())
    article: Mapped["ArticleModel"] = relationship()


class NewspaperModel(BaseModel):
    @declared_attr.directive
    def __tablename__(cls) -> str:
        return "newspapers"

    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), primary_key=True, default=uuid.uuid4
    )
    name: Mapped[str] = mapped_column(String)
    bias: Mapped[str] = mapped_column(String)
    description: Mapped[str] = mapped_column(Text)
    icon_url: Mapped[str] = mapped_column(String)
    logo_url: Mapped[str] = mapped_column(String)
    ownership_type = mapped_column(String, nullable=True)
    feeds: Mapped[List["FeedModel"]] = relationship(
        back_populates="newspaper", cascade="all, delete-orphan"
    )
    articles: Mapped[List["ArticleModel"]] = relationship(back_populates="newspaper")
    authors: Mapped[List["AuthorModel"]] = relationship(
        back_populates="newspaper", cascade="all, delete-orphan"
    )


class FeedModel(BaseModel):
    @declared_attr.directive
    def __tablename__(cls) -> str:
        return "feeds"

    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), primary_key=True, default=uuid.uuid4
    )
    newspaper_id: Mapped[uuid.UUID] = mapped_column(ForeignKey("newspapers.id"))
    url: Mapped[str] = mapped_column(String, unique=True, index=True)
    newspaper: Mapped["NewspaperModel"] = relationship(back_populates="feeds")
    is_active: Mapped[bool] = mapped_column(Boolean, default=True, index=True)
    blocklist: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    allowed_sections: Mapped[Optional[str]] = mapped_column(Text, nullable=True)


class AuthorModel(BaseModel):
    @declared_attr.directive
    def __tablename__(cls) -> str:
        return "authors"

    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), primary_key=True, default=uuid.uuid4
    )
    name: Mapped[str] = mapped_column(String)
    newspaper_id: Mapped[uuid.UUID] = mapped_column(ForeignKey("newspapers.id"))
    newspaper: Mapped["NewspaperModel"] = relationship(back_populates="authors")
    articles: Mapped[List["ArticleModel"]] = relationship(
        secondary=article_author_association, back_populates="authors"
    )


class MergeProposalModel(BaseModel):
    @declared_attr.directive
    def __tablename__(cls) -> str:
        return "merge_proposals"

    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), primary_key=True, default=uuid.uuid4
    )

    # Type of merge: 'article_merge' (Article -> Event) or 'event_merge' (Event -> Event)
    proposal_type: Mapped[str] = mapped_column(String, default="article_merge")

    # The Source (One of these must be set)
    source_article_id: Mapped[Optional[uuid.UUID]] = mapped_column(ForeignKey("articles.id"), nullable=True)
    source_event_id: Mapped[Optional[uuid.UUID]] = mapped_column(ForeignKey("news_events.id"), nullable=True)

    # The Target (Always an Event)
    target_event_id: Mapped[uuid.UUID] = mapped_column(ForeignKey("news_events.id"))

    distance_score: Mapped[float] = mapped_column(Float)
    reasoning: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    
    # Status: pending, approved, rejected, needs_human_review, executed, failed
    status: Mapped[str] = mapped_column(String, default="pending") 
    
    created_at: Mapped[datetime] = mapped_column(DateTime, default=func.now())

    # Relationships
    source_article: Mapped[Optional["ArticleModel"]] = relationship(
        foreign_keys=[source_article_id]
    )
    source_event: Mapped[Optional["NewsEventModel"]] = relationship(
        foreign_keys=[source_event_id]
    )
    target_event: Mapped["NewsEventModel"] = relationship(
        foreign_keys=[target_event_id]
    )

    __table_args__ = (
        # Unique constraint for Article merges
        UniqueConstraint("source_article_id", "target_event_id", name="uq_article_merge_pair"),
        # Unique constraint for Event merges
        UniqueConstraint("source_event_id", "target_event_id", name="uq_event_merge_pair"),
    )